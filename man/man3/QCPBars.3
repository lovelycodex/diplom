.TH "QCPBars" 3 "Thu Jun 18 2015" "Version v.2" "Voice analyze" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPBars \- A plottable representing a bar chart in a plot\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBWidthType\fP { \fBwtAbsolute\fP, \fBwtAxisRectRatio\fP, \fBwtPlotCoords\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPBars\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "double \fBwidth\fP () const "
.br
.ti -1c
.RI "\fBWidthType\fP \fBwidthType\fP () const "
.br
.ti -1c
.RI "\fBQCPBarsGroup\fP * \fBbarsGroup\fP () const "
.br
.ti -1c
.RI "double \fBbaseValue\fP () const "
.br
.ti -1c
.RI "\fBQCPBars\fP * \fBbarBelow\fP () const "
.br
.ti -1c
.RI "\fBQCPBars\fP * \fBbarAbove\fP () const "
.br
.ti -1c
.RI "\fBQCPBarDataMap\fP * \fBdata\fP () const "
.br
.ti -1c
.RI "void \fBsetWidth\fP (double width)"
.br
.ti -1c
.RI "void \fBsetWidthType\fP (\fBWidthType\fP widthType)"
.br
.ti -1c
.RI "void \fBsetBarsGroup\fP (\fBQCPBarsGroup\fP *barsGroup)"
.br
.ti -1c
.RI "void \fBsetBaseValue\fP (double baseValue)"
.br
.ti -1c
.RI "void \fBsetData\fP (\fBQCPBarDataMap\fP *data, bool copy=false)"
.br
.ti -1c
.RI "void \fBsetData\fP (const QVector< double > &key, const QVector< double > &value)"
.br
.ti -1c
.RI "void \fBmoveBelow\fP (\fBQCPBars\fP *bars)"
.br
.ti -1c
.RI "void \fBmoveAbove\fP (\fBQCPBars\fP *bars)"
.br
.ti -1c
.RI "void \fBaddData\fP (const \fBQCPBarDataMap\fP &dataMap)"
.br
.ti -1c
.RI "void \fBaddData\fP (const \fBQCPBarData\fP &data)"
.br
.ti -1c
.RI "void \fBaddData\fP (double key, double value)"
.br
.ti -1c
.RI "void \fBaddData\fP (const QVector< double > &keys, const QVector< double > &values)"
.br
.ti -1c
.RI "void \fBremoveDataBefore\fP (double key)"
.br
.ti -1c
.RI "void \fBremoveDataAfter\fP (double key)"
.br
.ti -1c
.RI "void \fBremoveData\fP (double fromKey, double toKey)"
.br
.ti -1c
.RI "void \fBremoveData\fP (double key)"
.br
.ti -1c
.RI "virtual void \fBclearData\fP ()"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const "
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBSignDomain\fP inSignDomain=\fBsdBoth\fP) const "
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBSignDomain\fP inSignDomain=\fBsdBoth\fP) const "
.br
.ti -1c
.RI "void \fBgetVisibleDataBounds\fP (QCPBarDataMap::const_iterator &lower, QCPBarDataMap::const_iterator &upperEnd) const "
.br
.ti -1c
.RI "QPolygonF \fBgetBarPolygon\fP (double key, double value) const "
.br
.ti -1c
.RI "void \fBgetPixelWidth\fP (double key, double &lower, double &upper) const "
.br
.ti -1c
.RI "double \fBgetStackedBaseValue\fP (double key, bool positive) const "
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBconnectBars\fP (\fBQCPBars\fP *lower, \fBQCPBars\fP *upper)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBQCPBarDataMap\fP * \fBmData\fP"
.br
.ti -1c
.RI "double \fBmWidth\fP"
.br
.ti -1c
.RI "\fBWidthType\fP \fBmWidthType\fP"
.br
.ti -1c
.RI "\fBQCPBarsGroup\fP * \fBmBarsGroup\fP"
.br
.ti -1c
.RI "double \fBmBaseValue\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPBars\fP > \fBmBarBelow\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPBars\fP > \fBmBarAbove\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBQCustomPlot\fP"
.br
.ti -1c
.RI "class \fBQCPLegend\fP"
.br
.ti -1c
.RI "class \fBQCPBarsGroup\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
A plottable representing a bar chart in a plot\&. 


.PP
To plot data, assign it with the \fBsetData\fP or \fBaddData\fP functions\&.
.SH "Changing the appearance"
.PP
The appearance of the bars is determined by the pen and the brush (\fBsetPen\fP, \fBsetBrush\fP)\&. The width of the individual bars can be controlled with \fBsetWidthType\fP and \fBsetWidth\fP\&.
.PP
Bar charts are stackable\&. This means, two \fBQCPBars\fP plottables can be placed on top of each other (see \fBQCPBars::moveAbove\fP)\&. So when two bars are at the same key position, they will appear stacked\&.
.PP
If you would like to group multiple \fBQCPBars\fP plottables together so they appear side by side as shown below, use \fBQCPBarsGroup\fP\&.
.PP
.SH "Usage"
.PP
Like all data representing objects in \fBQCustomPlot\fP, the \fBQCPBars\fP is a plottable (\fBQCPAbstractPlottable\fP)\&. So the plottable-interface of \fBQCustomPlot\fP applies (\fBQCustomPlot::plottable\fP, \fBQCustomPlot::addPlottable\fP, \fBQCustomPlot::removePlottable\fP, etc\&.)
.PP
Usually, you first create an instance: 
.PP
.nf

.fi
.PP
add it to the customPlot with \fBQCustomPlot::addPlottable\fP: 
.PP
.nf

.fi
.PP
and then modify the properties of the newly created plottable, e\&.g\&.: 
.PP
.nf

.fi
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQCPBars::WidthType\fP"
Defines the ways the width of the bar can be specified\&. Thus it defines what the number passed to \fBsetWidth\fP actually means\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetWidthType\fP, \fBsetWidth\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIwtAbsolute \fP\fP
Bar width is in absolute pixels\&. 
.TP
\fB\fIwtAxisRectRatio \fP\fP
Bar width is given by a fraction of the axis rect size\&. 
.TP
\fB\fIwtPlotCoords \fP\fP
Bar width is in key coordinates and thus scales with the key axis range\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPBars::QCPBars (\fBQCPAxis\fP * keyAxis, \fBQCPAxis\fP * valueAxis)\fC [explicit]\fP"
Constructs a bar chart which uses \fIkeyAxis\fP as its key axis ('x') and \fIvalueAxis\fP as its value axis ('y')\&. \fIkeyAxis\fP and \fIvalueAxis\fP must reside in the same \fBQCustomPlot\fP instance and not have the same orientation\&. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though\&.
.PP
The constructed \fBQCPBars\fP can be added to the plot with \fBQCustomPlot::addPlottable\fP, \fBQCustomPlot\fP then takes ownership of the bar chart\&. 
.SH "Member Function Documentation"
.PP 
.SS "void QCPBars::addData (const \fBQCPBarDataMap\fP & dataMap)"
Adds the provided data points in \fIdataMap\fP to the current data\&. 
.PP
\fBSee also:\fP
.RS 4
\fBremoveData\fP 
.RE
.PP

.SS "void QCPBars::addData (const \fBQCPBarData\fP & data)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. Adds the provided single data point in \fIdata\fP to the current data\&. 
.PP
\fBSee also:\fP
.RS 4
\fBremoveData\fP 
.RE
.PP

.SS "void QCPBars::addData (double key, double value)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. Adds the provided single data point as \fIkey\fP and \fIvalue\fP tuple to the current data 
.PP
\fBSee also:\fP
.RS 4
\fBremoveData\fP 
.RE
.PP

.SS "void QCPBars::addData (const QVector< double > & keys, const QVector< double > & values)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. Adds the provided data points as \fIkey\fP and \fIvalue\fP tuples to the current data\&. 
.PP
\fBSee also:\fP
.RS 4
\fBremoveData\fP 
.RE
.PP

.SS "\fBQCPBars\fP * QCPBars::barAbove () const\fC [inline]\fP"
Returns the bars plottable that is directly above this bars plottable\&. If there is no such plottable, returns 0\&.
.PP
\fBSee also:\fP
.RS 4
\fBbarBelow\fP, \fBmoveBelow\fP, \fBmoveAbove\fP 
.RE
.PP

.SS "\fBQCPBars\fP * QCPBars::barBelow () const\fC [inline]\fP"
Returns the bars plottable that is directly below this bars plottable\&. If there is no such plottable, returns 0\&.
.PP
\fBSee also:\fP
.RS 4
\fBbarAbove\fP, \fBmoveBelow\fP, \fBmoveAbove\fP 
.RE
.PP

.SS "void QCPBars::clearData ()\fC [virtual]\fP"
Removes all data points\&. 
.PP
\fBSee also:\fP
.RS 4
\fBremoveData\fP, \fBremoveDataAfter\fP, \fBremoveDataBefore\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.SS "void QCPBars::moveAbove (\fBQCPBars\fP * bars)"
Moves this bars plottable above \fIbars\fP\&. In other words, the bars of this plottable will appear above the bars of \fIbars\fP\&. The move target \fIbars\fP must use the same key and value axis as this plottable\&.
.PP
Inserting into and removing from existing bar stacking is handled gracefully\&. If \fIbars\fP already has a bars object below itself, this bars object is inserted between the two\&. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation\&.
.PP
To remove this bars plottable from any stacking, set \fIbars\fP to 0\&.
.PP
\fBSee also:\fP
.RS 4
\fBmoveBelow\fP, \fBbarBelow\fP, \fBbarAbove\fP 
.RE
.PP

.SS "void QCPBars::moveBelow (\fBQCPBars\fP * bars)"
Moves this bars plottable below \fIbars\fP\&. In other words, the bars of this plottable will appear below the bars of \fIbars\fP\&. The move target \fIbars\fP must use the same key and value axis as this plottable\&.
.PP
Inserting into and removing from existing bar stacking is handled gracefully\&. If \fIbars\fP already has a bars object below itself, this bars object is inserted between the two\&. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation\&.
.PP
To remove this bars plottable from any stacking, set \fIbars\fP to 0\&.
.PP
\fBSee also:\fP
.RS 4
\fBmoveBelow\fP, \fBbarAbove\fP, \fBbarBelow\fP 
.RE
.PP

.SS "void QCPBars::removeData (double fromKey, double toKey)"
Removes all data points with key between \fIfromKey\fP and \fItoKey\fP\&. if \fIfromKey\fP is greater or equal to \fItoKey\fP, the function does nothing\&. To remove a single data point with known key, use \fBremoveData(double key)\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddData\fP, \fBclearData\fP 
.RE
.PP

.SS "void QCPBars::removeData (double key)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Removes a single data point at \fIkey\fP\&. If the position is not known with absolute precision, consider using \fBremoveData(double fromKey, double toKey)\fP with a small fuzziness interval around the suspected position, depeding on the precision with which the key is known\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddData\fP, \fBclearData\fP 
.RE
.PP

.SS "void QCPBars::removeDataAfter (double key)"
Removes all data points with key greater than \fIkey\fP\&. 
.PP
\fBSee also:\fP
.RS 4
\fBaddData\fP, \fBclearData\fP 
.RE
.PP

.SS "void QCPBars::removeDataBefore (double key)"
Removes all data points with key smaller than \fIkey\fP\&. 
.PP
\fBSee also:\fP
.RS 4
\fBaddData\fP, \fBclearData\fP 
.RE
.PP

.SS "double QCPBars::selectTest (const QPointF & pos, bool onlySelectable, QVariant * details = \fC0\fP) const\fC [virtual]\fP"
This function is used to decide whether a click hits a layerable object or not\&.
.PP
\fIpos\fP is a point in pixel coordinates on the \fBQCustomPlot\fP surface\&. This function returns the shortest pixel distance of this point to the object\&. If the object is either invisible or the distance couldn't be determined, -1\&.0 is returned\&. Further, if \fIonlySelectable\fP is true and the object is not selectable, -1\&.0 is returned, too\&.
.PP
If the object is represented not by single lines but by an area like a \fBQCPItemText\fP or the bars of a \fBQCPBars\fP plottable, a click inside the area should also be considered a hit\&. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance\&. (typically the selectionTolerance multiplied by 0\&.99)\&.
.PP
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i\&.e\&. closer than 0\&.99*selectionTolerance)\&.
.PP
The actual setting of the selection state is not done by this function\&. This is handled by the parent \fBQCustomPlot\fP when the mouseReleaseEvent occurs, and the finally selected object is notified via the selectEvent/deselectEvent methods\&.
.PP
\fIdetails\fP is an optional output parameter\&. Every layerable subclass may place any information in \fIdetails\fP\&. This information will be passed to \fBselectEvent\fP when the parent \fBQCustomPlot\fP decides on the basis of this selectTest call, that the object was successfully selected\&. The subsequent call to \fBselectEvent\fP will carry the \fIdetails\fP\&. This is useful for multi-part objects (like \fBQCPAxis\fP)\&. This way, a possibly complex calculation to decide which part was clicked is only done once in \fBselectTest\fP\&. The result (i\&.e\&. the actually clicked part) can then be placed in \fIdetails\fP\&. So in the subsequent \fBselectEvent\fP, the decision which part was selected doesn't have to be done a second time for a single selection operation\&.
.PP
You may pass 0 as \fIdetails\fP to indicate that you are not interested in those selection details\&.
.PP
\fBSee also:\fP
.RS 4
selectEvent, deselectEvent, \fBQCustomPlot::setInteractions\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.SS "void QCPBars::setBarsGroup (\fBQCPBarsGroup\fP * barsGroup)"
Sets to which \fBQCPBarsGroup\fP this \fBQCPBars\fP instance belongs to\&. Alternatively, you can also use \fBQCPBarsGroup::append\fP\&.
.PP
To remove this \fBQCPBars\fP from any group, set \fIbarsGroup\fP to 0\&. 
.SS "void QCPBars::setBaseValue (double baseValue)"
Sets the base value of this bars plottable\&.
.PP
The base value defines where on the value coordinate the bars start\&. How far the bars extend from the base value is given by their individual value data\&. For example, if the base value is set to 1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at 3\&.
.PP
For stacked bars, only the base value of the bottom-most \fBQCPBars\fP has meaning\&.
.PP
The default base value is 0\&. 
.SS "void QCPBars::setData (\fBQCPBarDataMap\fP * data, bool copy = \fCfalse\fP)"
Replaces the current data with the provided \fIdata\fP\&.
.PP
If \fIcopy\fP is set to true, data points in \fIdata\fP will only be copied\&. if false, the plottable takes ownership of the passed data and replaces the internal data pointer with it\&. This is significantly faster than copying for large datasets\&. 
.SS "void QCPBars::setData (const QVector< double > & key, const QVector< double > & value)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Replaces the current data with the provided points in \fIkey\fP and \fIvalue\fP tuples\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&. 
.SS "void QCPBars::setWidth (double width)"
Sets the width of the bars\&.
.PP
How the number passed as \fIwidth\fP is interpreted (e\&.g\&. screen pixels, plot coordinates,\&.\&.\&.), depends on the currently set width type, see \fBsetWidthType\fP and \fBWidthType\fP\&. 
.SS "void QCPBars::setWidthType (\fBQCPBars::WidthType\fP widthType)"
Sets how the width of the bars is defined\&. See the documentation of \fBWidthType\fP for an explanation of the possible values for \fIwidthType\fP\&.
.PP
The default value is \fBwtPlotCoords\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetWidth\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Voice analyze from the source code\&.
